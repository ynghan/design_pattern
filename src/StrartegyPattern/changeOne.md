## 기존 설계
### originDesign

##   변경된 요구사항

### changeOneDesign

* Duck에 fly 동작을 추가해야한다.

  * 기존 설계에서 Duck 클래스에 fly() 메소드만 추가하면 된다.

* DucK의 종류가 늘었다 -> *RubberDuck*
  * quack() 메소드를 오버라이딩한다.
  * 그런데, RubberDuck은 날지 못하는 특성이 있다.

> RubberDuck 뿐만이 아닌 여러 Duck을 상속받는 하위 클래스가 늘어나면 각각의 클래스마다 오버라이딩을 지정해주어야 한다.

> 재사용을 목적으로 상속을 많이 사용하는 것은 유지 관리에 있어서 그다지 좋은 성과를 거두지 못했습니다.

### changeTwoDesign


> 하위 클래스의 증가를 위한 해결책을 찾아보자.

* 인터페이스를 활용해보자!
  * 코드 재사용을 완전히 파괴한다.
  * 또 다른 유지보수의 악몽을 일깨운다.
  * 날고있는 duck들 사이에서도 fly 행동은 하나가 아닐 수 있다.

> 애플리케이션의 다양한 측면을 파악하여 동일한 상태를 유지하는 것과 아닌 것을 분리하자.
* Duck 클래스에서 
  * 동일한 상태를 유지하는 것
    * swim(), display()
  * 동일한 상태를 유지하지 않는 것
    * quack(), fly()
  * Duck 클래스에서 두 메소드 모두를 빼낼 것입니다.
  * 각각의 동작을 나타내는 새로운 클래스 집합 만들 것입니다.
> 설계 원칙
* 구현이 아닌 인터페이스로 프로그래밍한다.
* 슈퍼 타입으로 프로그래밍한다.
* 다형성을 이용한다.
* 선언된 변수의 유형은 super 타입이어야 한다.
  * 이(super 타입)를 선언하는 클래스는 실제 객체 유형을 알 필요가 없습니다.
> 구현이 아닌 인터페이스를 위한 프로그램
* 구현을 위한 프로그래밍은 다음과 같습니다:
    ```java
        Dog d = new Dog();
        d.bark();
    ```
* 인터페이스/슈퍼타입으로의 프로그래밍은 다음과 같습니다:
  ```java
    Animal a = new Dog();
    a.makeSound();
  ```
* 코드의 하위 유형의 인스턴스를 하드 코딩하는 것보다 훨씬 더 좋습니다 
  * 실행 시 구체적인 구현 개체를 할당합니다:
  ```java
    Animal a = getAnimal("Dog");
    a.makeSound();
  ```

> 동적 행위 변경을 위해 setter 추가

> 대부분의 디자인 패턴은 가능할 때마다 상속보다 객체 구성을 강조합니다!!!